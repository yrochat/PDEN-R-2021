---
title: "Introduction à R"
subtitle: "Troisième partie"
author: "Yannick Rochat (yannick.rochat@epfl.ch)"
date: "19 mai 2021"
output:
    html_document
---

## Le plan du cours

* L'importation et l'exportation de données
* La visualisation de données
* ggplot2




## Manipuler des données

---


### Le package `readr` (et `questionr`)

À partir de là, nous allons utiliser les packages `questionr` pour obtenir un jeu de données et `readr` pour importer et exporter des tableaux de données.

---

### Installer un package

Nous avons vu comment installer un package. 

Pour rappel, il faut aller dans l'onglet "Packages" de la fenêtre en bas à droite, puis cliquer sur "Install" et entrer le nom du package. 

---

### Charger un package

Pour le charger dans l'environnement de travail : toujours dans l'onglet "Packages" en bas à droite, il faut trouver le package dont nous avons besoin et cocher la case correspondante.

---

Une fois installé, un package n'a plus besoin d'être installé. Il faudra de temps en temps le mettre à jour ("Update"), en particulier si vous recevez un warning vous indiquant de le faire.

Par contre, si un package est installé, cela ne signifie pas qu'il est chargé à chaque fois, c'est-à-dire que ses fonctions sont accessibles. Cela, il faudra le faire à chaque nouvelle session de travail.

----

* Les packages sont des ensembles de fonctions que l'on ajoute aux fonctions déjà disponibles.
* Les fonctions d'un package ont en général été regroupées autour d'une thématique commune.
* Dans notre cas: l'importation et l'exportation de données textuelles.

----


### Charger un jeu de données pré-enregistré

```{r}
library(questionr)
data("hdv2003")
```

Ce choix est inspiré du toujours excellent guide de Julien Barnier, à la page https://juba.github.io/tidyverse/03-premier_travail.html#jeu-de-donn%C3%A9es-dexemple

----

### Description

La fonction `head` permet de n'afficher que les premières lignes d'un vecteur ou d'un tableau.

```{r}
head(hdv2003)
```

### Description

```{r}
str(hdv2003)
```

----

### Accéder aux variables

```{r}
head(hdv2003$qualif)
```
----

### Accéder aux variables

```{r}
head(hdv2003$age)
```

---

### Accéder aux variables

Cette fonction est équivalente à la précente, mais la syntaxe n'indique pas de quelle variable il s'agit, seulement qu'il s'agit de la deuxième variable. Ce genre d'écriture est déconseillé.

```{r}
head(hdv2003[,2])
```


----


### Exporter des données (csv)

csv = "comma separated values"

Ne pas oublier les guillemets `"..."` autour du nom du fichier.

```{r}
library(readr)  # package pour l'importation et 
                # l'exportation de fichiers

write_csv(x = hdv2003, file = "hdv2003.csv")
```

----

### Importer des données (csv)

```{r}
hdv <- read_csv(file = "hdv2003.csv")
```

----

Pour consulter l'objet importé - dans ce cas un tableau de données - vous pouvez vous rendre dans la fenêtre en haut à droite de RStudio puis dans l'onglet "Environment". Vous trouverez le tableau sous "Data". En double-cliquant dessus, le tableau s'ouvrira dans cette fenêtre et vous pourrez vérifier qu'il a bien été importé (en particulier dans le cas de "parsing failures").

----


### Importer des données (xls)

xls (Microsoft Excel/libreOffice/Google Spreadsheets)

* On préfère en général sauver les fichiers au format csv car ils sont ainsi beaucoup plus légers et ne transportent pas l'encodage parfois lourd d'un fichier xls.

* Néanmoins, ce n'est pas toujours possible d'y échapper. Les données de l'OFS par exemple sont souvent fournies au format xls.

----

`readxl` est un package qui permet d'importer (et d'exporter) des fichiers au format xls.

---- 

Prenons un fichier au hasard de l'OFS : "Comportement de la population en matière de transport, chiffres clés - agglomération de Lausanne (définition 2000)"

https://www.bfs.admin.ch/bfs/fr/home/statistiques/catalogues-banques-donnees/tableaux.assetdetail.2082350.html

Il est présent dans le dossier.

----

La fonction `read_excel` est ce qu'il nous faut.

```{r}
library(readxl)
ouch <- read_excel("su-f-11.04.03-MZ-2015-A2_5586_Def2000.xls")
```

----

```{r}
ouch
```

----

Toutes les entrées sont considérées comme des chaînes de caractères, même les entrées numériques. Les en-têtes n'ont pas été convenablement importés. Dans ce cas, il existe différentes fonctions pour "nettoyer" le tableau, mais il vaut parfois mieux traiter le tableau en amont, puis exporter les données en csv (pas recommandé si l'on travaille régulièrement avec un même type de fichier : dans ce cas, il vaut mieux trouver un moyen d'automatiser le traitement).

----

```{r}
str(ouch)
```

----

Le résultat n'est pas directement exploitable, et ce sera souvent le cas au moment de récupérer des fichiers publics, souvent bizarrement structurés.

----

Important : les fonctions utilisées traditionnellement pour importer des tableaux (par ex. `read.table`) importent par défaut les variables au format "factor", un concept spécifique à R et aux langages prévus pour faire des statistiques. Ce format s'emploie principalement lorsqu'une variable est catégorielle ordinale, c'est-à-dire que les valeurs qu'elle peut prendre sont parmi un ensemble de "mots" (catégorielle) et qu'on peut les classer (ordinale), par exemple l'ensemble : "très mauvais", "mauvais", "bon", "très bon". 

Pour obtenir ce résultat, il faut utiliser (quand elle est disponible) l'option `stringsAsFactors = TRUE` qui est généralement vraie («`TRUE`») par défaut.

----

Le même genre de technique peut être utilisé pour lire des fichiers aux formats suivants.

but | fonction 
-------------|-------------
pur texte | `read_file`, `read_lines`
png | `readPNG`
spss | package `haven`
json | package `jsonlite`
xml | package `xml2`

---

La cheat sheet *Data Import* vous sera utile : https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-import.pdf





## Bien préparer ses données

«Tidy data is a standard way of mapping the meaning of a dataset to its structure.» 

«A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types.» 
Il est nécessaire de présenter ses données de manière "tidy" pour pouvoir utiliser `ggplot2`.

----

«In tidy data:

1. Each variable forms a column.
2. Each observation forms a row.
3. Each type of observational unit forms a table.»

Source :

```{r eval = FALSE}
library(tidyr)
vignette("tidy-data")
```

----

Marie-Louise Timcke a proposé sur `journocode.com` [une très bonne ressource à ce sujet](https://web.archive.org/web/20170212185744/http://journocode.com/2016/03/05/r-tidy-data/).


----

Le format *tidy*, ou *long form*, est fortement recommandé dans `ggplot2`.

Il y a une cheat sheet consacrée à la manipulation de ces objets : https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-transformation.pdf



## Produire une visualisation de données


`ggplot2` met en pratique **la grammaire des graphiques**, une théorie de Leland Wilkinson (1999). 

http://www.springer.com/us/book/9780387245447


## Charger les données dans ggplot

**Remarque** : à partir d'ici, nous parlons principalement de ggplot sans le "2" car il va s'agir de la fonction "ggplot". 

Le "2" n'est utilisé que dans le nom du package. 

Et oui, ggplot1 [existe](https://github.com/hadley/ggplot1).

## Setup. 

Charger (et si nécessaire installer) les packages `ggplot2` et `RColorBrewer`

```{r}
library(ggplot2)
library(RColorBrewer)
```



```{r, echo = FALSE}
# Indispensable pour exporter le notebook/les slides sans message d'erreur !?
library(knitr)
opts_knit$set(root.dir = '/')
```


## Un jeu de données interne à ggplot2

Nous utilisons un jeu de données interne à ggplot2 contenant le prix ainsi que d'autres attributs de 53 940 diamants.

Les commandes suivantes permettent de prendre connaissance du jeu de données.

```{r}
## help(diamonds)
## View(diamonds)
```

----

```{r}
head(diamonds)
```

----

```{r}
str(diamonds)
```

----

On ne va garder qu'un échantillon de mille observations tirées de ce jeu de données afin de rendre les calculs plus rapides et les graphiques moins chargés.

```{r}
diam <- diamonds[sample(1:nrow(diamonds), 1000),]
```


----

### On charge les données

*Attention ! L'input dans la fonction `ggplot` doit toujours être un data frame !*

```{r}
g <- ggplot(diam)
```

----

RStudio a bien identifié que nous avions chargé un tableau de données, mais ne sait pas quoi en faire. Au moins il n'y a pas de message d'erreur : on est sur la bonne voie.

```{r}
g
```

----

Contrairement à la fonction `plot`, qui bricole un visuel lorsqu'on entre la commande `plot(diamonds)`, avec `ggplot` il ne se passe rien.

Juste un grand carré gris.

----

Le résultat avec les packages pré-installés `base` et `graphics` (enlever les commentaires pour voir).

```{r}
## plot(diamonds)
```

La commande de base `plot(diamonds)` considère toutes les variables du data frame et les croise entre elles - numériques comme ordinales - pour un résultat illisible et inutile.

----

Pour avoir un aperçu des différences entre les options de base et `ggplot2` pour les représentations graphiques.

----

Voici les différents éléments propres à l'approche *grammaticale* des graphiques proposée par `ggplot2`, pour l'instant vides :

* layers

* scales

* mapping

* theme

* coordinates

* facet

----

À ce stade, le graphe est vide car nous n'avons défini ni mapping ni géométries (voir figure suivante).

----

```{r}
g <- ggplot(diam)
g
```

## Mapping

### Avec un mapping mais sans géométrie

cf. figure suivante.

Pour rappel : 'carat' et 'price' sont des variables continues.

`ggplot` arrive à représenter les échelles sur les axes.

----

```{r}
ggplot(diam, aes(x = carat, y = price)) 
```

----

On remarque que les échelles et les labels des axes sont déjà posés. 

`ggplot` attend maintenant de savoir quoi dessiner.

----

### Avec une géométrie mais sans mapping

Dans ce cas, pas de figure car il manque un mapping.

```{r, error = TRUE}
ggplot(diam) + geom_point()
```


----

### Avec un mapping et une géométrie

```{r}
ggplot(diam, aes(x = carat, y = price)) + geom_point()
```

----

Il s'agit de l'exemple le plus simple que nous pouvons produire.

Pour comparaison, la commande la plus simple permettant d'obtenir (à peu près) le même résultat avec le package de base.

```{r}
plot(diam$carat, diam$price)
```

----

Les échelles sont justes et les points sont bien situés, mais c'est tout et l'esthétique est datée.

----

C'est là le principe de ggplot : à partir de maintenant nous pouvons faire varier les éléments graphiques sans avoir à toucher aux données. Nous chargeons une seule fois le jeu de données, et ensuite nous pouvons nommer les variables directement, sans avoir à utiliser le symbole dollar.

Par exemple, dessinons une interpolation.

----

```{r}
ggplot(diam, aes(x = carat, y = price)) + geom_smooth()
```

## Superposer des layers

Il suffit d'additionner des layers pour les superposer.

**Attention** au '+' à mettre à la fin de la ligne et pas au début.

----

```{r}
ggplot(diam, aes(x = carat, y = price)) + 
  geom_point() + 
  geom_smooth()
```

----

L'ordre des géométries a une influence sur le graphique.

----

```{r}
ggplot(diam, aes(x = carat, y = price)) + 
  geom_smooth() + 
  geom_point()
```

----

Dans le graphique précédent, la courbe d'interpolation a été dessinée avant les points.

Ainsi, elle apparaît dans la figure cachée sous ces derniers.

## Différents mappings

Le mapping peut se faire à plusieurs endroits : 

* Dans `ggplot()`, ce qui a pour effet d'appliquer le mapping à tous les autres éléments.

* Dans les éléments graphiques eux-mêmes.

----

### Tout dans ggplot

```{r}
ggplot(diam, aes(x = carat, y = price)) + geom_point()
```

----

### Dans les deux

```{r}
ggplot(diam, aes(x = carat)) + geom_point(aes(y = price))
```

----

### Tout dans la géométrie

```{r}
ggplot(diam) + geom_point(aes(x = carat, y = price))
```

----

Nous verrons plus tard un exemple montrant quels effets peuvent avoir ces différents choix de mappings.

----


On peut mapper de nombreuses variables, en une seule fois, directement dans `ggplot` et elles seront reprises par les autres éléments. 

Par exemple, l'attribut `color` de `geom_point`. 

*Remarque* : ici, la variable 'clarity' est ordinale, `ggplot` fournit donc une palette de couleurs ordonnées.

----

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity)) + 
  geom_point()
```

----

Grâce à ce seul mapping, `ggplot` attribue à chaque modalité une couleur, attribue aux points la couleur correspondante, et génère dans la foulée une légende (une des angoisses lorsqu'on travaille avec les commandes de base).

Pour l'anecdote, nous aurions obtenu le même résultat en faisant le mapping dans `geom_point`.

----

```{r}
ggplot(diam, aes(x = carat, y = price)) + 
  geom_point(aes(color = clarity))
```

----

Attention à ne pas oublier de faire le mapping, c'est-à-dire d'utiliser la fonction `aes()`, sinon ça ne fonctionnera pas !

```{r, error = TRUE}
ggplot(diam, aes(x = carat, y = price)) + 
  geom_point(color = clarity)
```

----

On trouve toutes les géométries disponibles ainsi que de nombreuses autres ressources indispensables dans l'**indispensable** [cheat sheet de ggplot2](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf) !

---- 

Le lieu où se fait le mapping peut avoir une influence. Les Remarquez la différence entre les deux graphiques suivants.

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity)) + 
  geom_point() +
  geom_smooth()
```

----


```{r}
ggplot(diam, aes(x = carat, y = price)) + 
  geom_point(aes(color = clarity)) +
  geom_smooth()
```


----

### Variables et transformations, discrètes et continues

C'est hasardeux, mais on peut également appliquer une transformation continue (`size`) à une variable ordinale (`cut`).

----

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity, size = cut)) + 
  geom_point()
```

----

Toutefois, il est recommandé d'appliquer une transformation continue (`size`) à une variable continue (par exemple `depth`) et une transformation discrète comme la couleur ou la forme (`shape`) à une variable discrète (par exemple `cut`).

----

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity, shape = cut)) + 
  geom_point()
```

----

D'autres exemples concernant les attributs des éléments géométriques.

----

### Transformation continue, variable continue

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity, size = depth)) + 
  geom_point()
```

----

Il est possible évidemment de modifier plus subtilement la taille des sommets lorsqu'on fait un mapping dessus, si les valeurs par défaut ne nous plaisent pas. 

En général, cela passe par les fonctions `scale`. 

Elles commencent par `scale_` (voir la cheat sheet). 

Nous reviendrons plus en détail là-dessus.

Dans la figure suivante, nous donnons des valeurs minimales et maximales pour la taille des sommets.

----

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity, size = depth)) + 
  geom_point() + 
  scale_size(range = c(1,3))
```

----

*Remarque* : l'effet est difficile à observer car la variance est très petite.

```{r}
summary(diam$depth)
sd(diam$depth)
```

----

Au passage, remarquons que l'on peut aussi utiliser l'attribut `size` de `geom_point` sans mapping.

----

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity)) + 
  geom_point(size = 1)
```

----

Dans ce cas, la taille des points est considérée hors mapping et donc indépendamment d'une quelconque variable.

----

Remarquons également l'organisation hiérarchique des mappings et des transformations : dans l'exemple qui suit, la variable  `depth` est tout d'abord mappée sur la taille des sommets. 

Puis, dans `geom_point`, on lui attribue une valeur fixe. 

Arrivée ensuite, c'est cette dernière qui l'emporte sur le mapping initial.

----

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity, size = depth)) + 
  geom_point(size = 1)
```

----

Au passage, la modification du titre en légende dépend de la fonction `scale` correspondante (ici `scale_size`). La clarté dépend du mapping sur la couleur (d'où l'emploi de `scale_color_discrete`, car c'est une variable discrète).

C'est logique, mais contre-intuitif pour qui aura passé beaucoup de temps avec les commandes graphiques de base dans R.

----

```{r}
ggplot(diam, aes(x = carat, y = price, color = clarity, size = depth)) + 
  geom_point() + 
  scale_size("DEPTH", range = c(1,3)) +
  scale_color_discrete("Clarté")
```

## Bilan intermédiaire

Nous avons vu comment :

* Charger les données.

* Faire un mapping.

* Superposer une ou plusieurs géométries.

